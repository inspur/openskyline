export default {
  container: {
    containerService: "Container Service",
    containerCluster: "Container Cluster",
    deployedCluster: "Deployed Cluster",
    deployedClusterDesc: "Deployed cluster is Kubernetes cluster created by cluster template." +
      "Project administrator can manage the clusters of the project, super administrator needs to switch to a project and have project administrator privileges.",
    clusterTemplate: "Cluster Template",
    clusterTemplateDesc: "Cluster template is used to deploy Kubernetes cluster." +
      "Project administrator can manage the cluster template of the project, super administrator needs to switch to a project and have project administrator privileges.",
    containerImage: "Container Image",
    containerImageDesc: "Please build the Harbor service before using container image.",
    imageGroup: "Image Group",
    image: "Image",
    containerInstance: "Container Instance",
    containerInstanceDesc: "Super administrator has only the view permissions for container instance. Project administrators or project users have administrative operation privileges.",
    containerApp: "App",
    appDetail: "App Detail",
    basicInfo: "Basic Information",
    nodeList: "Nodes List",
    container: "Container",
    environmentParam: "Environment Variable",
    service: "Service",
    hpa: "HPA",
    event: "Event",
    pod: "Pod",
    podDetail: "Pod Detail",
    command: "Command",
    parameter: "Parameter",
    log: "Log",
    monitor: "Monitor",
    containerVolume: "Container Volume",
    containerVolumeDesc: "Container volume refers to data volumes that can be mounted to containers for data persistence, currently only support Ceph RBD." +
      "Project administrators or project users have administrative operation privileges.super administrator needs to switch to a project to manage container volume.",
    containerApp2Desc: "Volume mounted to ironc cluster's application only support iscsi",
    masterNodeCount: "Master Node Count",
    nodeCount: "Slave Node Count",
    masterAndNodes:"Master/Slave Node Count",
    keypair: "Keypair",
    create: "Create",
    startMonitor: "Start Monitor",
    startMonitorConfirmMsg: "Confirm to start monitor?",
    startMonitorSuccessMsg: "Start monitor successfully",
    startMonitorFailMsg: "Start monitor failed",
    stopMonitor: "Stop Monitor",
    stopMonitoring: "Stopping monitor",
    stopMonitorConfirmMsg: "Confirm to stop monitor?",
    startDelete: "Start deleting",
    startMonitorErrorTip1: "The image required for the system does not exist. Please upload 'influxdb:v0.5' and 'heapster:v1.2.0' under the 'system' image group in container image: ",
    startMonitorErrorTip2: ", then start monitor.",
    stopMonitorErrorTip: "Please stop HPA of all applications in the cluster first.",
    unknown: "Unknown",
    started: "Started",
    stopped: "Stopped",
    starting: "Starting",
    stopping: "Stopping",
    createContainerCluster: "Create Container Cluster",
    others: "Others",
    startCreating: "Start creating",
    timeout: "Timeout",
    minute: "Minute",
    clusterTemplateName: "Cluster Template Name",
    clusterTemplateId: "Cluster Template ID",
    apiAddress: "API Address",
    masterNodeAddress: "Master Node Address",
    nodeAddress: "Slave Node Address",
    heatStack: "Orchestration Stack",
    timeoutMin: "Timeout(Minute)",
    masterNodeFlavor: "Master Node Flavor",
    nodeFlavor: "Slave Node Flavor",
    deleteSuccessMsg: "Delete successfully",
    availabilityZone: "Availability Zone",
    storageDriver: "Storage Driver",
    volumeSizeGB: "Volume Size(GB)",
    externalNetwork: "External Network",
    fixedNetwork: "Fixed Network",
    fixedSubnet: "Fixed Subnet",
    imageLibray: "Image Libray",
    pauseImageAddress: "Pause Image Address",
    createContainerTemplate: "Create Container Template",
    setNodeFlavor: "Config Node Flavor",
    network: "Network",
    createSuccessMsg: "Create successfully",
    availabilityZoneDesc: "If the selected availability zone is deleted or renamed, cluster creation will fail.",
    k8sAlert: "This version is not supported at this time。",
    k8sValidatorDesc: "The version list needs to upload the virtual machine image and set the correct metadata information.",
    imageDesc: "The operate system of the image must be Fedora-automic, otherwise cluster creation will fail.",
    masterNodeFlavorDesc: "Flavor of the cloud host used by the master node.",
    nodeFlavorDesc: "Flavor of the cloud host used by the slave node.",
    storageType: "Storage Type",
    storageDriverDesc: '"overlay" storage driver type is selected, the minimum volume size is 1GB.<br>' +
      '"devicemapper" is selected, the minimum volume size is 3GB.',
    core: "Core",
    memory: "Memory",
    hardDisk: "Hard disk",
    externalNetworkDesc: "The selected external network needs to maintain connectivity with the Openstack management network.",
    fixedNetworkDesc: "If fixed network and subnet are selected, make sure there is a corresponding router between them and the selected external network.<br>" +
      "If fixed network and subnet are not selected, system will create one with CIDR 10.0.0.0/24 automatically and generate router between them and the selected external network.",
    pauseImage: "Pause Image",
    pauseImageVersion: "Pause Image Version",
    modifyContainerTemplate: "Modify Container Template",
    modifySuccessMsg: "Modify successfully",
    ok: "OK",
    creating: "Creating",
    updating: "Updating",
    serverError: "Server Error",
    authError: "Auth Error",
    ipPortError: "IP or Port Error",
    createHarbor: "Add Harbor service",
    harborIPDesc: "Harbor service management IP.",
    modifyHarbor: "Modify Harbor service",
    imageCount: "Image Count",
    tagCount: "Tag Count",
    pullCount: "Pull Count",
    pushImage: "Push Image",
    containerImageAuthError: "Authentication failure.",
    pushImageTip: "Reference command to push a image to current project.",
    dockerTag: "Tag a image in project",
    dockerPush: "Push image to current project",
    pullCommand: "Pull Command",
    imageCreateTime: "Image Create Time",
    dockerVersion: "Docker Version",
    structure: "Structure",
    os: "OS",
    creator: "Creator",
    sizeMB: "Size(MB)",
    attachedCluster: "Attached Cluster",
    attachedApp: "Attached App",
    attach: "Attach",
    detach: "Detach",
    detachVolumeConfirmMsg: "Application can not read data in volume after detaching, confirm to continue?",
    available: "Available",
    attached: "Attached",
    attaching: "Attaching",
    detaching: "Detaching",
    attachError: "Attach Error",
    detachError: "Detach Error",
    detachSuccessMsg: "Detach successfully",
    createVolume: "Create Volume",
    size: "Size",
    attachToContainerApp: "Attach to Container App",
    attachToContainerAppTip: "The number of copies of container application will become 1 after the volume is attached.<br>" +
      "An incorrect path for the volume may cause the application to remain in operation.Users in this situation must detach the volume and attach the volume to another path.",
    attachToContainerAppTip2: "An incorrect path for the volume may cause the application to remain in operation.<br>" +
      "Users in this situation must detach the volume and attach the volume to another path.",
    cluster: "Cluster",
    attachPath: "Path",
    attachPathTip1: "Path must be an absolute path starting with / and not allowed as a root directory",
    attachPathTip2: "Commonly used path:",
    attachPathTip3: "the specific mount point needs to refer to the image description file.",
    attachPathTip4: "If the path is existed in the application, it will recover thr origanl path",
    attachPathTip5: "If more than two volume mount to thte same application and the same menu, may cose the app error.",
    copyNumber: "Copy Number",
    attachedVolume: "Attached Volume",
    running: "Running",
    closed: "Closed",
    processing: "Processing",
    open: "Open",
    close: "Close",
    openAppConfirmMsg: "Confirm to open app?",
    openAppMsg: "Opening",
    closeApppConfirmMsg: "Confirm to close app?",
    closeAppMsg: "Closing",
    attachVolume: "Attach Volume",
    detachVolume: "Detach Volume",
    deleting: "Deleting",
    deleteAppConfirmMsg: "Confirm to delete app? Input YES to continue.",
    startHpa: "Start HPA",
    startClusterMonitorMsg: "Please start cluster monitor.",
    modifyHpa: "Modify HPA",
    stopHpa: "Stop HPA",
    stopHpaConfirmMsg: "Confirm to stop HPA?",
    createContainerApp: "Create Container App",
    tags: "Tags",
    portConfig: "Port Config",
    dosConfig: "Dos Config",
    notallow: "Not allow submit parameters without command",
    version: "Version",
    appType: "Service Type",
    stateful: "Stateful",
    stateless: "Stateless",
    statefulDesc: "For data persistence,user stateful service.",
    cpuNumber_copy: "CPU of One Copy",
    memorySize_copy: "Memory of One Copy",
    key: "Key",
    keyExistError: "Key is already exist.",
    value: "Value",
    operate: "Operate",
    add: "Add",
    portName: "Port Name",
    portNameExistError: "Port name is already exist.",
    containerPort: "Container Port",
    portIsnotSame: "The container port must be the same as the port in the selected image.",
    containerPortExistError: "Container port is already exist.",
    protocol: "Protocol",
    nodeServicePort: "Node Service Port",
    nodeServicePortExistError: "Node service port is already exist.",
    autoAllocation: "Automatic",
    Manualy: "Manualy",
    atLeastOnePort: "Please add at least one port.",
    modifyContainerInstance: "Modify Container Instance",
    attachSuccessMsg: "Attach successfully",
    appName: "App Name",
    minCopyNumber: "Minimum number of copies",
    minCopyNumber4App: "The minimum number of app copies",
    maxCopyNumber: "Maximum number of copies",
    maxCopyNumber4App: "The maximum number of app's scale",
    cpuThreshold: "CPU Threshold(%)",
    cpuThresholdDesc: "The ratio of the CPU occupied by the container instance to the total CPU.",
    everyDay: "Everyday",
    everyNDay: "Every N Day",
    everyNHour: "Every N Hour",
    everyWeek: "Every Week",
    everyMonth: "Every Month",
    sunday: "Sunday",
    saturday: "Saturday",
    friday: "Friday",
    thursday: "Thursday",
    wednesday: "Wednesday",
    tuesday: "Tuesday",
    monday: "Monday",
    minCopyBiggerThanMaxCopy: "The minimum copy number can not bigger than the maximum copy number",
    copyNumberTitle: "Running/Total",
    address: "Address",
    hostIP: "Host IP",
    abnormal: "Abnormal",
    selector: "Selector",
    internalIP: "Internal IP",
    portList: "Port List",
    startHpaTip: "Please start HPA first.",
    hpaVolumeMsg: "Application has mounted volume, it can not start HPA",
    eventList: "Event List",
    detail: "Detail",
    time: "Time",
    resConfig: "Rescource Config",
    startMonitorTip: "Please start cluster monitor first.",
    cpuUsage: "CPU Usage",
    memUsage: "Memory Usage",
    networkFlow: "Network Flow",
    upload: "Upload",
    download: "Download",
    oneHour: "1 Hour",
    oneDay: "1 Day",
    oneWeek: "1 Week",
    storageNetwork: "Storage Network",
    storageSubnet: "Storage Subnet",
    applyEventName: "Apply Event Name",
    applyEvent: "Apply Event",
    applyEventDetail: "Apply Event Detail",
    containerEventName: "Container Event Name",
    containerEvent: "Container Event",
    containerEventDetail: "Container Event Detail",
    diyTag: "DIY Tags",
    tagMaxlength: "The max size of custom tag is {0}",
    reservedKey: "{0} is reserved key, can not be edited",
    addNode: "Add Node",
    deleteNode: "Delete Node",
    addNodeCount: "Add Node Count",
    deleteNodeCount: "Delete Node Count",
    oldNodeCount: "Orgin Node Count",
    minNodeSize: "The min count of node is 1",
    maxNodeSizePerOper: "You can add 10 nodes per times",
    dontRepeatSubmit: "The operation executing,pls dondt repeat submit",
    everyHour: "Every Hour",
    kubernetesCluster: "Kubernetes Cluster",
    clusterName: "Cluster Name",
    clusterVersion: "Cluster Version",
    clusterNetwork: "Cluster Network",
    clusterSubnetwork: "Cluster SubNetwork",
    clusterDescription: "Cluster Description",
    belongProject: "Belong Project",
    clusterState: "Cluster Status",
    masternodeIP: "Master IP",
    workernodeIP: "Worker IP",
    timeouts: "Time Out",
    createkbCluster: "Create Kubernetes",
    "CREATE_IN_PROGRESS": "CREATE_IN_PROGRESS",
    "CREATE_FAILED": "CREATE_FAILED",
    "CREATE_COMPLETE": "CREATE_COMPLETE",
    "DELETE_IN_PROGRESS": "DELETE_IN_PROGRESS",
    "DELETE_COMPLETE": "DELETE_COMPLETE",
    "DELETE_FAILED": "DELETE_FAILED",
    "SUSPEND_IN_PROGRESS": "SUSPEND_IN_PROGRESS",
    "SUSPEND_COMPLETE": "SUSPEND_COMPLETE",
    "SUSPEND_FAILED": "SUSPEND_FAILED",
    "RESUME_IN_PROGRESS": "RESUME_IN_PROGRESS",
    "RESUME_COMPLETE": "RESUME_COMPLETE",
    "RESUME_FAILED": "RESUME_FAILED",
    "ROLLBACK_IN_PROGRESS": "ROLLBACK_IN_PROGRESS",
    "ROLLBACK_COMPLETE": "ROLLBACK_COMPLETE",
    "ROLLBACK_FAILED": "ROLLBACK_FAILED",
    "SNAPSHOT_IN_PROGRESS": "SNAPSHOT_IN_PROGRESS",
    "SNAPSHOT_COMPLETE": "SNAPSHOT_COMPLETE",
    "SNAPSHOT_FAILED": "SNAPSHOT_FAILED",
    "UPDATE_IN_PROGRESS": "UPDATE_IN_PROGRESS",
    "UPDATE_COMPLETE": "UPDATE_COMPLETE",
    "UPDATE_FAILED": "UPDATE_FAILED",
    "CHECK_IN_PROGRESS": "CHECK_IN_PROGRESS",
    "CHECK_COMPLETE": "CHECK_COMPLETE",
    "CHECK_FAILED": "CHECK_FAILED",
    "INIT_IN_PROGRESS": "INIT_IN_PROGRESS",
    "INIT_COMPLETE": "INIT_COMPLETE",
    "INIT_FAILED": "INIT_FAILED",
    "ADOPT_IN_PROGRESS": "ADOPT_IN_PROGRESS",
    "ADOPT_COMPLETE": "ADOPT_COMPLETE",
    "ADOPT_FAILED": "ADOPT_FAILED",
    "unavailable": "kubernetes unavailable",
    "provisioning": "kubernetes provisioning",
    "active": "kubernetes active",
    "removing": "kubernetes removing",
    "runstate": "Status",
    "applicationType": "Type",
    "containerTeam": "Container Team",
    "serviceSet": "Service Set",
    "accessType": "Access Type",
    "innerAccess": "Inner Access",
    "outerAccess": "Outer Access",
    "containerTeamList": "Container Team List",
    "containerTeamName": "Name",
    "listenerPort": "Listener Port",
    "targetPort": "Target Port",
    "nodeName": "Node Name",
    "nodeIP": "Node IP",
    "nodeState": "Node State",
    "nodesFlavor": "Node Flavor",
    "nodeRole": "Node Role",
    "serviceState": "Cluster State",
    "deleteRequest": "Delete Request Success",
    "volumeNote": "Bigger than 3GB",
    "createRequest": "Create Request Success",
    "registering": "registering",
    "required": "This field is required",
    "nodePort": "Node Port",
    "listenerPortExistError": "Listener Port is exist.",
    "storageProvider": "Storage Provider",
    "removeNode": "Remove Node",
    "removeNodeNumber": "Remove Node Number",
    "belongCluster": "Belong Cluster",
    "addStorageProvider": "Add Storage Provider",
    "outPort": "External Port",
    "oldMasterNumber": "Master Node Number",
    "addworkNote": "Worker node and Master node mast less than 10",
    "removeworkNote": "Worker node number must more than 1",
    "workerConfig": "Worker Config",
    "masterConfig": "Master Config",
    "startMode": "Start Mode",
    "volumeStart": "Start from Volume",
    "editStorageProvider": "Edit Storage Provider",
    "passwordNote": "It's the user's login password",
    "volumeNote2": "If not select volume type when create, use default instead",
    "volumeNote3": "If not select volume type, use default",
    "mountstatus": "Mount Status",
    "unmounted": "UnMount",
    "storageVolume": "Storage Volume",
    "portMaxNote": "The max port number is 10",
    "maxteamLength": "The max container team list is 5",
    "containerTeanNameCheck": "The name is repeat",
    "passwordError": "The password is error",
    "serviceTabNote": "The statefulset application must depend on a inner service to ordering the pod, this inner service will be create always",
    "repeatnameError": "The name is repeat",
    "networkNoteCheck": "This ip is not in cidr",
    "deviceConnect": "Device Set",
    "podcidrNote": "In k8s cluster for pod deploy Cluster IP, suggest to use 16 mask",
    "servercidrNote": "In k8s cluster for Service allocate Cluster IP, suggest to use 16 mask",
    "dnsserveripNote": "In k8s cluster for Service analysis IP, need to in Service CIDR",
    "advanceSet": "Advanced",
    "volumeNumber": "Volume Number",
    "appManage": "Application Manage",
    maxSizeOnevolCapa: "Max Size One volume Capability is 128TB",
    accountLocked: "The user is locked",
    mountVolume: "Mount Volume",
    mountedVolumeList: "Mounted Volume List",
    selectVolumeList: "Select Volume",
    createStation: "Position",
    aztotal: "AZ Total",
    vmaz: "VM(By AZ)",
    vmproject: "VM(By Project)",
    cpuallocate: "CPU allocate",
    hostcputotal: "Host CPU Cores",
    vmcputotal: "VM CPU Cores",
    memallocate: "Memory allocate",
    hostmemtotal: "Host memory total",
    vmhosttotal: "VM Host Total",
    storageallocate: "Storage ",
    realstoragetotal: "Real Storage total",
    storageused: "Storage used",
    storageblocktotal: "Volume used",
    startModTip: "When select volume start, Master cannot select physical machine",
    startModTip2: "When select volume start, Worker cannot select physical machine",
    byProject: "(By Project)",
    blockStorage: "Block Project",
    serviceNormal: "Service Normal",
    serviceUnnormal: "Service UnNormal",
    subnetNote1: "If the cluster subnet contains",
    subnetNote2: "IP, then you need to add network set on advance set",
    or: "or",
    maxis: "max is",
    filestorageused: "File Storage Usage",
    objectstorageused: "Object Storage Usage",
    addContainer: "Add Container",
    blockName: "superuser",
    blockPs: "passw0rd",
    replicasNote: "If select volumes, then the replicas set is invalidate",
    X509_ERROR: "X509_ERROR",
    AUTH_ERROR: "AUTH_ERROR",
    IP_PORT_ERROR: "IP_PORT_ERROR",
    HARBOR_SERVER_ERROR: "HARBOR_SERVER_ERROR",
    cniPlus: "cni plus",
    ironicTips: "Only support volume type is iscsi",
    openBalance: "Open Balance",
    closeBalance: "Close Balance",
    memThreshold: "Memory Threshold(%)",
    setScaling: "Set Scaling",
    setScalingSuccess: "Set Scaling Success",
    replicasCompare: "max_replicas must bigger than min_replicas",
    blockStorageUsage: "Volume Usage",
    realUsage: "USage",
    objectStorageUsage: "Object Storage USage",
    customStartPage: "StartPage&Dashboard Custom Set",
    hostNum: "Host Number",
    top5Hostnum: "TOP5-Bare host number",
    top5cpuusage: "TOP5-CPU Usage(History)",
    top5memusage: "TOP5-Memory Usage(History)",
    top5netspeed: "TOP5-Network Rate(History)",
    unhealthyHost: "Unhealthy Host",
    unhealthvm: "Unhealthy VM",
    diskin: "Disk in",
    diskout: "Disk out",
    startPageCustom: "StartPage Custom",
    bigscreenCustom: "Dashboard Custom",
    startpage_custom_note: "Note: After custom, you must refresh the page",
    setScalingSet: "Scaling set",
    scalingCompare: "Capacity low level must less than high level",
    minReplicasTip: "The min replicas suggest set to except value",
    unsupport: "UnSupport",
    volumesupportTips: "Unsupport the share volume types.",
    cniTips: "flannel:use in a simple network case.<br>calico:support custom network, need higher performance",
    connecting: "Connectingy.....",
    deleteContainerDisk: "Delete container volume in the same time",
    addacontainer: "At least add one container",
    clustertokenfailed: "Cluster token get failed",
    deleteDiskNote: "If the cluster's status is unnormal, the disk may not be deleted automatically",
    clusterMonitor: "Cluster Monitors",
    clusterInfo: "Cluster Detail",
    monitorStatus: "Prometheus Monitor",
    cpuused: "Used",
    cpuleft: "Left",
    cputotal: "CPU Total",
    memtotal: "Memory Total",
    deployment: "Deployment",
    statefulSet: "StatefulSet",
    daemonSet: "DaemonSet",
    configFile: "Config File",
    k8sversion: "K8S Version",
    showCPUCore: "C",
    kubeletInfo: "kubelet Normal Amount/Total Amount",
    deployStep: "Deploy Step",
    compStatus: "Component Status",
    deployStep1: "If the prometheus is installed, please chech the cluster status, else execute steps like this:",
    deployStep2: "1、copy kubeconfig file to any master node ~/.kube/config",
    deployStep3: "2、run kubectl apply -f /opt/prom/manifests/setup",
    deployStep4: "3、run kubectl apply -f /opt/prom/manifests"
  }
};
